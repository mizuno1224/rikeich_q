<h2 class="prob-title-sub">総合演習：様々な物理シミュレーション</h2>
<p>
  このページでは，<strong>Matter.js</strong>（物理演算），<strong>JSXGraph</strong>（数学グラフ），<strong>Chart.js</strong>（データ可視化），<strong>p5.js</strong>（アニメーション），そして <strong>Three.js</strong>（3Dグラフィックス）を1つの解説記事内で組み合わせて使用するサンプルを示します。
</p>

<h3>1. 剛体の衝突実験 (Matter.js)</h3>
<p>
  斜面上を滑り落ちる箱と，床にある障害物の衝突を物理エンジンで計算します。
  摩擦や反発係数をリアルにシミュレートできます。
</p>

<div id="sim-sample-matter" class="sim-embed" style="height: 400px; border: 2px solid #3b82f6;"></div>

<div class="box-alert">
  <span class="box-alert-label">Point</span>
  <p>クリック・ドラッグで物体を動かすことができます。</p>
</div>

<script>
  (function() {
    const el = document.getElementById('sim-sample-matter');
    if (!el) return;

    // Matter.js エイリアス
    const { Engine, Render, Runner, World, Bodies, Mouse, MouseConstraint, Composite } = Matter;

    // エンジン作成
    const engine = Engine.create();
    const world = engine.world;

    // レンダラー作成
    const render = Render.create({
      element: el,
      engine: engine,
      options: {
        width: el.clientWidth,
        height: el.clientHeight,
        wireframes: false,
        background: '#f1f5f9'
      }
    });

    // 物体作成
    // 1. 斜面 (静止)
    const slope = Bodies.rectangle(200, 200, 400, 20, {
      isStatic: true,
      angle: Math.PI / 6, // 30度
      render: { fillStyle: '#64748b' }
    });

    // 2. 床 (静止)
    const ground = Bodies.rectangle(el.clientWidth / 2, el.clientHeight - 10, el.clientWidth, 40, {
      isStatic: true,
      render: { fillStyle: '#64748b' }
    });

    // 3. 滑る箱
    const box = Bodies.rectangle(100, 50, 40, 40, {
      friction: 0.05,
      restitution: 0.6,
      render: { fillStyle: '#f43f5e' }
    });

    // 4. 障害物タワー
    const stack = [];
    for (let i = 0; i < 3; i++) {
      stack.push(Bodies.rectangle(500, el.clientHeight - 50 - i * 40, 40, 40, {
        render: { fillStyle: '#3b82f6' }
      }));
    }

    World.add(world, [slope, ground, box, ...stack]);

    // マウス操作追加
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: { stiffness: 0.2, render: { visible: false } }
    });
    World.add(world, mouseConstraint);
    render.mouse = mouse;

    // 実行
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);
  })();
</script>


<h3>2. パラメータによるグラフ変化 (JSXGraph)</h3>
<p>
  二次関数 $y = ax^2 + bx + c$ の係数をスライダーで動かし，放物線の形状変化を確認します。
</p>

<div id="graph-sample-jxg" class="sim-embed" style="height: 400px; width: 100%;"></div>

<script>
  (function() {
    const id = 'graph-sample-jxg';
    if (!document.getElementById(id)) return;

    // ボード初期化
    const board = JXG.JSXGraph.initBoard(id, {
      boundingbox: [-5, 10, 5, -5],
      axis: true,
      showCopyright: false,
      pan: { enabled: true },
      zoom: { enabled: true }
    });

    // スライダー作成
    // [x1, y1], [x2, y2], [min, start, max]
    const a = board.create('slider', [[-4, 8], [-1, 8], [-2, 0.5, 2]], { name: 'a', label: { fontSize: 16 } });
    const b = board.create('slider', [[-4, 7], [-1, 7], [-5, 0, 5]], { name: 'b', label: { fontSize: 16 } });
    const c = board.create('slider', [[-4, 6], [-1, 6], [-5, 0, 5]], { name: 'c', label: { fontSize: 16 } });

    // グラフ描画
    const f = board.create('functiongraph', [function(x) {
      return a.Value() * x * x + b.Value() * x + c.Value();
    }], { strokeWidth: 3, strokeColor: '#f43f5e' });

    // テキスト表示
    board.create('text', [2, 8, function() {
      return `y = ${a.Value().toFixed(2)}x² + ${b.Value().toFixed(2)}x + ${c.Value().toFixed(2)}`;
    }], { fontSize: 16 });
  })();
</script>


<h3>3. 実験データの可視化 (Chart.js)</h3>
<p>
  物体の運動に伴うエネルギー変化のグラフです。
</p>

<div class="sim-embed" style="height: 300px;">
  <canvas id="chart-sample-energy"></canvas>
</div>

<script>
  (function() {
    const ctx = document.getElementById('chart-sample-energy');
    if (!ctx) return;

    // ダミーデータ生成
    const labels = [];
    const dataK = []; // 運動エネルギー
    const dataU = []; // 位置エネルギー
    const dataE = []; // 力学的エネルギー
    
    for (let t = 0; t <= 20; t++) {
      const time = t * 0.2;
      const h = 10 - 4.9 * time * time * 0.1; // 適当な落下モデル
      const v = 9.8 * time * 0.1;
      
      const K = 0.5 * 1.0 * v * v;
      const U = 1.0 * 9.8 * Math.max(0, h);
      
      labels.push(time.toFixed(1) + 's');
      dataK.push(K);
      dataU.push(U);
      dataE.push(K + U);
    }

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          { label: '運動エネルギー K', data: dataK, borderColor: '#3b82f6', tension: 0.4 },
          { label: '位置エネルギー U', data: dataU, borderColor: '#f43f5e', tension: 0.4 },
          { label: '力学的エネルギー E', data: dataE, borderColor: '#10b981', borderDash: [5, 5] }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: { beginAtZero: true, title: { display: true, text: 'Energy [J]' } }
        }
      }
    });
  })();
</script>


<h3>4. ベクトルアニメーション (p5.js)</h3>
<p>
  p5.jsを用いたシンプルな単振動のベクトル表示です。
</p>

<div id="sim-sample-p5" class="sim-embed" style="height: 300px;"></div>

<script>
  (function() {
    if (!document.getElementById('sim-sample-p5')) return;

    const sketch = (p) => {
      let angle = 0;
      
      p.setup = () => {
        const c = document.getElementById('sim-sample-p5');
        p.createCanvas(c.clientWidth, c.clientHeight).parent(c);
      };

      p.draw = () => {
        p.background(248, 250, 252); // base color
        
        // 中心移動
        p.translate(p.width / 2, p.height / 2);
        
        const r = 80;
        const x = r * p.cos(angle);
        const y = r * p.sin(angle);
        
        // 円軌道
        p.noFill();
        p.stroke(200);
        p.ellipse(0, 0, r * 2);
        
        // 動く点
        p.fill(59, 130, 246);
        p.noStroke();
        p.ellipse(x, y, 20);
        
        // 中心からの線
        p.stroke(59, 130, 246);
        p.line(0, 0, x, y);
        
        // x成分の射影
        p.fill(244, 63, 94);
        p.noStroke();
        p.ellipse(x, 120, 15);
        p.stroke(244, 63, 94, 100);
        p.line(x, y, x, 120);
        
        angle += 0.05;
      };

      p.windowResized = () => {
        const c = document.getElementById('sim-sample-p5');
        if(c) p.resizeCanvas(c.clientWidth, c.clientHeight);
      };
    };

    // インスタンス管理に追加
    const p5inst = new p5(sketch);
    if (!window.p5Instances) window.p5Instances = [];
    window.p5Instances.push(p5inst);
  })();
</script>


<h3>5. 3D空間での実験 (Three.js)</h3>
<p>
  <strong>Three.js</strong> を使うと，空間的な配置や立体的な動きを表現できます。
  電磁気学（磁場と電流）や，天体の運動などの解説に非常に有効です。<br>
  （※マウスドラッグで回転，ホイールで拡大縮小が可能です）
</p>

<div id="sim-sample-three" class="sim-embed" style="height: 400px; background: #000;"></div>

<script>
  (function() {
    const container = document.getElementById('sim-sample-three');
    if (!container) return;

    // 1. シーン・カメラ・レンダラー設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf1f5f9);

    const w = container.clientWidth;
    const h = container.clientHeight;
    const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 100);
    camera.position.set(4, 4, 6);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    container.appendChild(renderer.domElement);

    // 2. カメラコントロール (OrbitControls)
    // viewer.html で読み込み済みのため直接利用可能
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // 3. ライト設定
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // 4. オブジェクト配置
    const gridHelper = new THREE.GridHelper(10, 10, 0x94a3b8, 0xcbd5e1);
    scene.add(gridHelper);
    
    const axesHelper = new THREE.AxesHelper(2);
    scene.add(axesHelper);

    // 球体
    const sphereGeo = new THREE.SphereGeometry(0.8, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({ 
      color: 0x3b82f6, 
      roughness: 0.4,
      metalness: 0.3
    });
    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
    scene.add(sphere);

    // 立方体
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    const boxMat = new THREE.MeshStandardMaterial({ color: 0xf43f5e });
    const box = new THREE.Mesh(boxGeo, boxMat);
    box.position.set(-2, 1, -2);
    scene.add(box);

    // 5. アニメーションループ
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      
      const t = clock.getElapsedTime();

      // オブジェクトの動き
      sphere.position.y = Math.abs(Math.sin(t * 3)) * 2 + 0.8; 
      sphere.position.x = Math.cos(t) * 2;
      sphere.position.z = Math.sin(t) * 2;

      box.rotation.x += 0.01;
      box.rotation.y += 0.02;

      // コントロールの更新
      controls.update();

      renderer.render(scene, camera);
    }
    animate();

    // リサイズ対応
    window.addEventListener('resize', () => {
       if(!container) return;
       const newW = container.clientWidth;
       const newH = container.clientHeight;
       renderer.setSize(newW, newH);
       camera.aspect = newW / newH;
       camera.updateProjectionMatrix();
    });
  })();
</script>