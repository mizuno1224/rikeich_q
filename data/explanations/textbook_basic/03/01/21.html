<h2 class="prob-title-sub">例題4：正弦波の反射（自由端）</h2>

<div class="card">
  <h3>解法の指針</h3>
  <p>
    自由端における反射は，固定端とは異なり<strong>位相がずれません</strong>。作図のポイントは以下の通りです。
  </p>
  <div class="box-note">
    <strong>自由端反射の作図 2ステップ</strong>
    <ol>
      <li><strong>延長する</strong>：壁がないと仮定して，入射波をそのまま壁の奥へ描く。</li>
      <li><strong>折り返す</strong>：<span class="highlight">壁（$x=9$）を対称軸として線対称</span>に折り返す。これが反射波になる（上下反転はしない）。</li>
    </ol>
  </div>
  <p>
    合成波は，固定端と同様に入射波と反射波の変位を足し合わせることで描けます。
  </p>
</div>

<div class="card">
  <h3>(1) 合成波の形成シミュレーション</h3>
  
  <p>
    以下のシミュレーションは，波が進み，自由端（$x=9$）で反射して定常波が完成するまで進み，<strong>「答えの瞬間（入射波の谷が原点にあるとき）」に自動でストップ</strong>します。<br>
    固定端の場合と違い，壁の位置で波が大きく振動する（腹になる）様子を確認してください。
  </p>

  <div id="sim-free-reflection-v3" class="sim-embed"></div>
  <script>
    (function(){
      var containerId = 'sim-free-reflection-v3';
      var container = document.getElementById(containerId);
      if(!container) return;

      // Canvas setup
      var canvas = document.createElement('canvas');
      canvas.width = 700;
      canvas.height = 460;
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.backgroundColor = '#fff';
      canvas.style.border = '1px solid #ccc';
      canvas.style.borderRadius = '4px';
      container.appendChild(canvas);
      var ctx = canvas.getContext('2d');

      // Constants
      var grid = 35; 
      var originX = 60; 
      var originY = 230; 
      var wallGrid = 9; 
      var wallX = wallGrid * grid; 
      
      var amp = 2.0 * grid; // 振幅
      var lambda = 8 * grid; // 波長
      var k = 2 * Math.PI / lambda;
      var waveSpeed = 2.0; // 速度

      // State
      var isAnimating = true;
      var animId;
      var showInc = true;
      var showRef = true;
      var showComp = true;

      // Target Calculation
      // 条件: 入射波の谷(-A)が原点(x=0)に来る。
      // 入射波: y = A * sin(k(x - frontX))
      // x=0 で y = A * sin(-k*frontX) = -A * sin(k*frontX)
      // -A * sin(...) = -A  =>  sin(k*frontX) = 1
      // k*frontX = pi/2 + 2n*pi
      // frontX = 2grid + 8n*grid
      // 定常波完成のため frontX >= 18grid 程度必要。
      // n=3 のとき frontX = 2 + 24 = 26 grid.
      
      var startFront = -4 * grid; 
      var targetFront = 26 * grid; // 谷が原点に来る瞬間
      var t = startFront; // t is frontX

      // UI Container
      var uiDiv = document.createElement('div');
      uiDiv.style.marginTop = '12px';
      uiDiv.style.textAlign = 'center';
      uiDiv.style.fontFamily = 'sans-serif';
      container.appendChild(uiDiv);

      // Toggles
      var toggleDiv = document.createElement('div');
      toggleDiv.style.marginBottom = '12px';
      toggleDiv.style.display = 'flex';
      toggleDiv.style.justifyContent = 'center';
      toggleDiv.style.gap = '15px';
      uiDiv.appendChild(toggleDiv);

      function createToggle(label, color, initial, cb) {
        var l = document.createElement('label');
        l.style.cursor = 'pointer';
        l.style.display = 'flex';
        l.style.alignItems = 'center';
        var i = document.createElement('input');
        i.type = 'checkbox'; i.checked = initial;
        i.onchange = function(e){ cb(e.target.checked); };
        var s = document.createElement('span');
        s.textContent = label; s.style.color = color; s.style.fontWeight = 'bold'; s.style.marginLeft = '4px';
        l.appendChild(i); l.appendChild(s);
        return l;
      }

      toggleDiv.appendChild(createToggle('入射波 (青)', '#007bff', true, function(v){ showInc=v; draw(); }));
      toggleDiv.appendChild(createToggle('反射波 (緑)', '#28a745', true, function(v){ showRef=v; draw(); }));
      toggleDiv.appendChild(createToggle('合成波 (赤)', '#dc3545', true, function(v){ showComp=v; draw(); }));

      // Buttons
      var btnDiv = document.createElement('div');
      btnDiv.style.display = 'flex';
      btnDiv.style.justifyContent = 'center';
      btnDiv.style.flexWrap = 'wrap';
      btnDiv.style.gap = '8px';
      uiDiv.appendChild(btnDiv);

      function createBtn(text, fn, primary) {
        var b = document.createElement('button');
        b.innerHTML = text;
        b.style.padding = '6px 14px';
        b.style.fontSize = '14px';
        b.style.cursor = 'pointer';
        b.style.background = primary ? '#dc3545' : '#f8f9fa';
        b.style.color = primary ? '#fff' : '#333';
        b.style.border = '1px solid #ccc';
        b.style.borderRadius = '4px';
        b.onclick = fn;
        return b;
      }

      // Drawing Logic
      function getIncY(x, frontX) {
        return amp * Math.sin(k * (x - frontX));
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 1;
        for(var i=-2; i<=15; i++){
          var x = originX + i*grid;
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
          // Coord labels
          if(i===0 || i===9 || i===5) {
             ctx.fillStyle = '#aaa'; ctx.font = '10px sans-serif';
             ctx.fillText(i, x+2, originY+15);
          }
        }
        for(var j=-5; j<=5; j++){
          var y = originY + j*grid;
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(canvas.width, originY); ctx.stroke();
        
        // Wall (x=9) - Free End
        var wx = originX + wallX;
        ctx.setLineDash([5, 4]); 
        ctx.beginPath(); ctx.moveTo(wx, 20); ctx.lineTo(wx, canvas.height-20); ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#000'; ctx.font = 'bold 16px sans-serif';
        // Label "P (自由端)" removed as requested
        // Just O label
        ctx.fillText('O', originX - 15, originY + 20);

        // --- Wave Calculation ---
        var tipRef = 2 * wallX - t; 

        // 1. Incident Wave
        if(showInc) {
          ctx.strokeStyle = '#007bff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          var first = true;
          for(var x = -3*grid; x <= t; x += 2) {
            if(x > wallX + 8*grid) break;
            var y = getIncY(x, t);
            var dx = originX + x;
            var dy = originY - y;
            if(x > wallX) ctx.globalAlpha = 0.3;
            else ctx.globalAlpha = 1.0;
            if(first){ ctx.moveTo(dx, dy); first=false; }
            else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }

        // 2. Reflected Wave (Free End: No Inversion)
        if(showRef && t > wallX) {
          ctx.strokeStyle = '#28a745';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 4]);
          ctx.beginPath();
          var first = true;
          
          for(var x = -3*grid; x <= wallX; x += 2) {
            if(x < tipRef) continue;
            var x_virt = 2*wallX - x;
            var y_virt = getIncY(x_virt, t);
            var y_ref = y_virt; // No inversion
            var dx = originX + x;
            var dy = originY - y_ref;
            if(first){ ctx.moveTo(dx, dy); first=false; }
            else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Source (Symmetric on right)
          if(showInc) {
            ctx.strokeStyle = '#28a745';
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            var f2=true;
            for(var x=wallX; x<=t; x+=2) {
              if(x > wallX + 8*grid) break;
              var y = getIncY(x, t); // No inversion
              var dx = originX + x;
              var dy = originY - y;
              if(f2){ ctx.moveTo(dx, dy); f2=false; }
              else ctx.lineTo(dx, dy);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
          }
        }

        // 3. Composite Wave
        if(showComp && t > wallX) {
          ctx.strokeStyle = '#dc3545';
          ctx.lineWidth = 4;
          ctx.beginPath();
          var first = true;
          for(var x = -3*grid; x <= wallX; x += 2) {
             if(x > t) break;
             var y_sum = 0;
             y_sum += getIncY(x, t);
             if(x >= tipRef) {
                var x_virt = 2*wallX - x;
                y_sum += getIncY(x_virt, t); 
             }
             var dx = originX + x;
             var dy = originY - y_sum;
             if(first){ ctx.moveTo(dx, dy); first=false; }
             else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
        }

        // 4. Highlight Answer Moment
        if(!isAnimating && Math.abs(t - targetFront) < 1.0) {
           ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
           ctx.fillRect(wx - 260, 10, 250, 35);
           ctx.strokeStyle = '#d00'; ctx.lineWidth=2; ctx.strokeRect(wx - 260, 10, 250, 35);

           ctx.fillStyle = '#d00';
           ctx.font = 'bold 16px sans-serif';
           ctx.fillText('★ 答えの瞬間 (定常波完成)', wx - 240, 34);
           
           // Nodes
           // Free End(9) is Antinode.
           // Nodes: 7, 3, -1
           var nodes = [7, 3, -1];
           ctx.lineWidth = 2; 
           ctx.strokeStyle = '#333';
           
           nodes.forEach(function(n){
             var nx = originX + n*grid;
             if(nx < 0) return;
             ctx.beginPath(); ctx.arc(nx, originY, 7, 0, Math.PI*2);
             ctx.fillStyle = '#fff'; ctx.fill(); ctx.stroke();
             // Label
             if(n===7 || n===3) {
               ctx.fillStyle = '#333'; ctx.font = '12px sans-serif';
               ctx.fillText('節', nx-6, originY-14);
             }
           });
        }
      }

      function loop() {
        if(!isAnimating) return;
        t += waveSpeed;
        if(t >= targetFront) {
          t = targetFront;
          isAnimating = false;
        }
        draw();
        if(isAnimating) animId = requestAnimationFrame(loop);
      }

      // Buttons
      btnDiv.appendChild(createBtn('⏮ 最初から', function(){ 
        isAnimating=true; t=startFront; loop(); 
      }));
      btnDiv.appendChild(createBtn('⏪ -1コマ', function(){ 
        isAnimating=false; 
        t = Math.max(startFront, t - grid/4); 
        draw(); 
      }));
      btnDiv.appendChild(createBtn('再生 / 停止', function(){ 
        if(t >= targetFront) t = startFront; 
        isAnimating = !isAnimating; 
        if(isAnimating) loop(); 
      }));
      btnDiv.appendChild(createBtn('+1コマ ⏩', function(){ 
        isAnimating=false; 
        t += grid/4; 
        draw(); 
      }));
      btnDiv.appendChild(createBtn('★ 答えの瞬間', function(){ 
        isAnimating=false; 
        t = targetFront; 
        draw(); 
      }, true));

      // Init
      loop();
    })();
  </script>

  <div class="box-note">
    <strong>解答のポイント：</strong><br>
    <ul>
      <li><strong>合成波の形状</strong>：図の赤線のように，自由端（$x=9$）で大きく振動する（腹になる）波形になります。</li>
      <li><strong>節（ふし）の位置</strong>：
        <ul>
          <li><strong>自由端（$x=9$）</strong>：ここは<strong>腹</strong>になります（最大振幅）。</li>
          <li><strong>節の位置</strong>：腹から $\frac{\lambda}{4}$（2目盛り）ずれた位置に現れます。すなわち <strong>$x=7, 3, -1$</strong> が節となります（図の白丸）。</li>
        </ul>
      </li>
    </ul>
  </div>
</div>

<div class="box-alert">
  <span class="box-alert-label">Point</span>
  <h3>定常波の節と腹の位置関係（自由端 $x=9$）</h3>
  <p>
    自由端（$x=9$）を基準に考えると：
  </p>
  <ul>
    <li>$x=9$（自由端）：<strong>腹</strong></li>
    <li>$x=7$（$1/4$波長）：<span class="highlight">節</span></li>
    <li>$x=5$（$1/2$波長）：腹</li>
    <li>$x=3$：<span class="highlight">節</span></li>
    <li>$x=1$：腹</li>
  </ul>
  <p>
    このように，自由端から $\lambda/4$ （2目盛り）ごとに節と腹が交互に並びます。
  </p>
</div>