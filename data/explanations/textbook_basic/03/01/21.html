<h2 class="prob-title-sub">例題4：正弦波の反射</h2>

<div class="card">
  <h3>解法の指針</h3>
  <p>
    波の反射と合成の問題では、以下の手順で作図を行います。
  </p>
  <ul>
    <li><strong>反射波の作図（自由端）：</strong> 入射波を壁の奥まで延長し、それを<span class="highlight">壁（$x=9$）を軸として線対称</span>に折り返します。</li>
    <li><strong>合成波の作図：</strong> 「入射波の変位」と「反射波の変位」を足し合わせます。</li>
  </ul>
  <p>
    ここでは、波の先端が原点より左から出発して壁に反射し、入射波の谷底が原点（$x=0$）の位置に来た瞬間の合成波を考えます。
  </p>
</div>

<div class="card">
  <h3>(1) 合成波の形成シミュレーション</h3>
  
  <p>
    以下のシミュレーションで、波が進み、自由端（$x=9$）で反射して合成波ができる様子を確認しましょう。<br>
    チェックボックスでそれぞれの波の表示・非表示を切り替えることができます。<br>
    <strong>「答えの瞬間」</strong>では、定常波の<strong>節</strong>となる位置に〇が表示されます。
  </p>

  <div id="sim-wave-reflection-grid-v8" class="sim-embed"></div>
  <script>
    (function(){
      const containerId = 'sim-wave-reflection-grid-v8';
      const container = document.getElementById(containerId);
      if(!container) return;

      // Canvas setup
      const canvas = document.createElement('canvas');
      canvas.width = 650;
      canvas.height = 420;
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.backgroundColor = '#fff';
      canvas.style.border = '1px solid #ddd';
      container.appendChild(canvas);
      const ctx = canvas.getContext('2d');

      // Constants
      const grid = 40; // 1目盛り = 40px
      const originX = 120; // x=0 の描画位置
      const originY = 210;
      const wallGrid = 9; // 壁の位置 x=9
      const wallX = wallGrid * grid; // 原点からの相対距離
      
      // 入射波の振幅を2マス分に設定
      const amp = 2.0 * grid; 
      
      const lambda = 8 * grid; // 波長 = 8マス
      const k = 2 * Math.PI / lambda;
      const waveSpeed = 5; // pixels per tick

      // State
      let t = 0; 
      let isAnimating = false;
      let animId;
      
      // Visibility flags
      let showInc = true;
      let showRef = true;
      let showComp = true;

      // UI Elements Container
      const uiContainer = document.createElement('div');
      uiContainer.style.marginTop = '10px';
      uiContainer.style.fontFamily = 'sans-serif';
      uiContainer.style.fontSize = '14px';
      container.appendChild(uiContainer);

      // 1. Toggles Row
      const toggleRow = document.createElement('div');
      toggleRow.style.display = 'flex';
      toggleRow.style.justifyContent = 'center';
      toggleRow.style.gap = '15px';
      toggleRow.style.marginBottom = '10px';
      uiContainer.appendChild(toggleRow);

      const createToggle = (label, color, initial, onChange) => {
        const wrapper = document.createElement('label');
        wrapper.style.display = 'flex';
        wrapper.style.alignItems = 'center';
        wrapper.style.gap = '5px';
        wrapper.style.cursor = 'pointer';
        
        const box = document.createElement('input');
        box.type = 'checkbox';
        box.checked = initial;
        box.onchange = (e) => onChange(e.target.checked);
        
        const text = document.createElement('span');
        text.textContent = label;
        text.style.color = color;
        text.style.fontWeight = 'bold';
        
        wrapper.appendChild(box);
        wrapper.appendChild(text);
        return wrapper;
      };

      toggleRow.appendChild(createToggle('入射波 (青)', '#007bff', true, (v) => { showInc = v; draw(); }));
      toggleRow.appendChild(createToggle('反射波 (緑)', '#28a745', true, (v) => { showRef = v; draw(); }));
      toggleRow.appendChild(createToggle('合成波 (赤)', '#dc3545', true, (v) => { showComp = v; draw(); }));

      // 2. Controls Row
      const controls = document.createElement('div');
      controls.style.display = 'flex';
      controls.style.justifyContent = 'center';
      controls.style.flexWrap = 'wrap';
      controls.style.gap = '8px';
      uiContainer.appendChild(controls);

      const btn = (text, fn, primary=false) => {
        const b = document.createElement('button');
        b.innerHTML = text;
        b.className = primary ? 'btn-primary' : 'btn-simple';
        b.style.padding = '6px 12px';
        b.style.cursor = 'pointer';
        b.style.background = primary ? '#007bff' : '#f0f0f0';
        b.style.color = primary ? '#fff' : '#333';
        b.style.border = '1px solid #ccc';
        b.style.borderRadius = '4px';
        b.onclick = fn;
        return b;
      };

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Grid
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#e0e0e0';
        
        // Vertical lines (from x=-2 to x=10)
        for(let i = -2; i <= 10; i++) {
          const x = originX + i * grid;
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
          // Labels
          if(i <= 10) {
            ctx.fillStyle = '#666'; ctx.font = '12px sans-serif';
            ctx.fillText(i, x - 4, originY + 20);
          }
        }
        
        // Horizontal lines
        for(let j=-4; j<=4; j++) {
          const y = originY + j * grid;
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }

        // Wall
        const wallDrawX = originX + wallX;
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath(); ctx.moveTo(wallDrawX, 0); ctx.lineTo(wallDrawX, canvas.height); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#000'; ctx.font = 'bold 14px sans-serif';
        ctx.fillText('P (自由端)', wallDrawX + 5, 30);
        ctx.fillText('x=9', wallDrawX + 5, 50);

        // Wave Parameters
        const frontX = t;
        const startDraw = -2 * grid;
        const maxDraw = Math.max(frontX, wallX + 200);

        // 2. Incident Wave (Blue)
        if (showInc) {
          ctx.strokeStyle = '#007bff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          let first = true;

          for(let x = startDraw; x <= maxDraw; x += 2) {
            if (x > frontX) break; 

            const val = -amp * Math.cos(k * (x - t));
            
            if (x > wallX) ctx.globalAlpha = 0.3; // Virtual part
            else ctx.globalAlpha = 1.0;

            if(first) { ctx.moveTo(originX + x, originY - val); first=false; }
            else ctx.lineTo(originX + x, originY - val);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }

        // 3. Reflected Wave (Green)
        if (showRef && frontX > wallX) {
          ctx.strokeStyle = '#28a745';
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          let first = true;
          
          for(let x = startDraw; x <= wallX; x += 2) {
             if (x < 18*grid - t) continue;

             const val = -amp * Math.cos(k * ((18*grid - x) - t));
             
             if (first) { 
                ctx.moveTo(originX + x, originY - val); 
                first = false; 
             } else { 
                ctx.lineTo(originX + x, originY - val); 
             }
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // 4. Composite Wave (Red)
        if (showComp && frontX > wallX) {
          ctx.strokeStyle = '#dc3545';
          ctx.lineWidth = 4;
          ctx.beginPath();
          let first = true;

          for(let x = startDraw; x <= wallX; x += 2) {
             let ySum = 0;
             ySum += -amp * Math.cos(k * (x - t));
             
             if (x >= 18*grid - t) {
                ySum += -amp * Math.cos(k * ((18*grid - x) - t));
             }

             if(first) { ctx.moveTo(originX + x, originY - ySum); first=false; }
             else ctx.lineTo(originX + x, originY - ySum);
          }
          ctx.stroke();
        }

        // Highlight "Answer Moment" and Nodes
        if (Math.abs(t - 24*grid) < 2) {
          ctx.fillStyle = '#d00';
          ctx.font = 'bold 16px sans-serif';
          ctx.fillText('答えの瞬間', 20, 30);
          
          // Draw Nodes (Circles)
          // 自由端(x=9)は腹。節はそこから λ/4 = 2grid ごと。
          // 節の位置: x=7, x=3, x=-1
          const nodes = [7, 3, -1];
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.fillStyle = '#fff'; // 白塗りで目立たせる

          nodes.forEach(nx => {
             const cx = originX + nx * grid;
             const cy = originY; // y=0 axis
             ctx.beginPath();
             ctx.arc(cx, cy, 6, 0, Math.PI*2);
             ctx.fill();
             ctx.stroke();
             
             // Label "節"
             ctx.fillStyle = '#333';
             ctx.font = '12px sans-serif';
             ctx.fillText('節', cx - 6, cy - 12);
             ctx.fillStyle = '#fff'; // reset for next circle
          });
        }
      }

      function loop() {
        if(!isAnimating) return;
        t += waveSpeed;
        if(t > 24 * grid) {
          t = 24 * grid;
          isAnimating = false;
        }
        draw();
        animId = requestAnimationFrame(loop);
      }

      // Buttons
      controls.appendChild(btn('⏮ 最初から', () => { isAnimating=false; t=0; draw(); }));
      
      controls.appendChild(btn('⏪ -1コマ', () => { 
        isAnimating=false; 
        t = Math.max(0, t - grid/2); 
        draw(); 
      }));
      
      controls.appendChild(btn('再生 / 停止', () => { 
        isAnimating = !isAnimating; 
        if(isAnimating) loop(); 
      }));

      controls.appendChild(btn('+1コマ ⏩', () => { 
        isAnimating=false; 
        t += grid/2; 
        draw(); 
      }));
      
      controls.appendChild(btn('★ 答えの瞬間', () => {
        isAnimating=false;
        t = 24 * grid; 
        draw();
      }, true));

      // Init
      draw();

    })();
  </script>

  <div class="box-note">
    <strong>シミュレーションの使い方</strong><br>
    <ul>
      <li><strong>チェックボックス：</strong> 入射波、反射波、合成波の表示を個別にON/OFFできます。</li>
      <li><strong>答えの瞬間：</strong> 合成波が完成し、定常波の<strong>節（x=-1, 3, 7）</strong>の位置に〇印が表示されます。このとき、節の部分は振動せず、腹の部分（x=1, 5, 9）は大きく振動していることがわかります。</li>
    </ul>
  </div>
</div>

<div class="box-alert">
  <span class="box-alert-label">Point</span>
  <h3>定常波の節と腹の位置関係（自由端 x=9）</h3>
  <p>
    自由端（$x=9$）を基準に考えると：
  </p>
  <ul>
    <li>$x=9$（自由端）：<strong>腹</strong></li>
    <li>$x=7$（$1/4$波長）：<span class="highlight">節</span></li>
    <li>$x=5$（$1/2$波長）：腹</li>
    <li>$x=3$：<span class="highlight">節</span></li>
    <li>$x=1$：腹</li>
    <li>$x=-1$：<span class="highlight">節</span></li>
  </ul>
  <p>
    このように、自由端から $\lambda/4$ （2目盛り）ごとに節と腹が交互に並びます。
  </p>
</div>