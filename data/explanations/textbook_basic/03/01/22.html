<h2 class="prob-title-sub">類題4：正弦波の反射（固定端）</h2>

<div class="card">
  <h3>解法の指針</h3>
  <p>
    この問題は、壁（固定端）で反射した波が、やってくる波（入射波）と重なり合ってできる<strong>定常波（定在波）</strong>を作図する問題です。<br>
    いきなり答えの波を描こうとせず、以下の手順で論理的に作図するのが鉄則です。
  </p>
  <div class="box-note">
    <strong>固定端反射の作図 3ステップ</strong>
    <ol>
      <li><strong>延長する</strong>：壁がないと仮定して、入射波をそのまま壁の奥へ描く（透過波）。</li>
      <li><strong>反転する</strong>：固定端では位相が $\pi$ ずれるため、壁の奥の波を<span class="highlight">上下反転</span>させる。</li>
      <li><strong>折り返す</strong>：<strong>壁</strong>を対称軸として、反転した波を左右に折り返す。これが<strong>反射波</strong>になる。</li>
    </ol>
  </div>
  <p>
    最後に、入射波と反射波の高さ（変位）を足し合わせることで、<strong>合成波</strong>が得られます。
  </p>
</div>

<div class="card">
  <h3>(1) 定常波の作図と節の位置</h3>
  
  <h4>考え方</h4>
  <p>
    問題の設定は、壁の位置が $x=9$ で、入射波の谷が原点 $O$ にある瞬間です。<br>
    以下のシミュレーションは、波が壁に反射して定常波ができあがるまで進み、<strong>条件を満たす「答えの瞬間」に自動でストップ</strong>します。<br>
    コマ送り機能を使って、入射波と反射波がどのように重なっていくかを確認してください。
  </p>

  <div id="sim-fixed-reflection-v5" class="sim-embed"></div>
  <script>
    (function(){
      var containerId = 'sim-fixed-reflection-v5';
      var container = document.getElementById(containerId);
      if(!container) return;

      // Canvas setup
      var canvas = document.createElement('canvas');
      canvas.width = 700;
      canvas.height = 460;
      canvas.style.width = '100%';
      canvas.style.height = 'auto';
      canvas.style.backgroundColor = '#fff';
      canvas.style.border = '1px solid #ccc';
      canvas.style.borderRadius = '4px';
      container.appendChild(canvas);
      var ctx = canvas.getContext('2d');

      // Constants
      var grid = 35; 
      var originX = 60; 
      var originY = 230; 
      var wallGrid = 9; 
      var wallX = wallGrid * grid; 
      
      var amp = 2.0 * grid; // 振幅：縦2マス
      var lambda = 8 * grid; // 波長：8マス
      var k = 2 * Math.PI / lambda;
      var waveSpeed = 2.0; // 再生速度

      // State
      var isAnimating = true; 
      var animId;
      var showInc = true;
      var showRef = true;
      var showComp = true;

      // ターゲット計算（答えの瞬間）
      // 条件: x=0 で入射波が谷(-A)になる。
      // 入射波の式: y = A * sin( k * (x - frontX) )
      // 定常波完成のため frontX = 26 grid をターゲットにする。
      var startFront = -4 * grid; // 初期位置
      var targetFront = 26 * grid; // 停止位置
      var t = startFront; 
      
      // UI Container
      var uiDiv = document.createElement('div');
      uiDiv.style.marginTop = '12px';
      uiDiv.style.textAlign = 'center';
      uiDiv.style.fontFamily = 'sans-serif';
      container.appendChild(uiDiv);

      // Toggles
      var toggleDiv = document.createElement('div');
      toggleDiv.style.marginBottom = '12px';
      toggleDiv.style.display = 'flex';
      toggleDiv.style.justifyContent = 'center';
      toggleDiv.style.gap = '15px';
      uiDiv.appendChild(toggleDiv);

      function createToggle(label, color, initial, cb) {
        var l = document.createElement('label');
        l.style.cursor = 'pointer';
        l.style.display = 'flex';
        l.style.alignItems = 'center';
        var i = document.createElement('input');
        i.type = 'checkbox'; i.checked = initial;
        i.onchange = function(e){ cb(e.target.checked); };
        var s = document.createElement('span');
        s.textContent = label; s.style.color = color; s.style.fontWeight = 'bold'; s.style.marginLeft = '4px';
        l.appendChild(i); l.appendChild(s);
        return l;
      }

      toggleDiv.appendChild(createToggle('入射波 (青)', '#007bff', true, function(v){ showInc=v; draw(); }));
      toggleDiv.appendChild(createToggle('反射波 (緑)', '#28a745', true, function(v){ showRef=v; draw(); }));
      toggleDiv.appendChild(createToggle('合成波 (赤)', '#dc3545', true, function(v){ showComp=v; draw(); }));

      // Buttons
      var btnDiv = document.createElement('div');
      btnDiv.style.display = 'flex';
      btnDiv.style.justifyContent = 'center';
      btnDiv.style.flexWrap = 'wrap';
      btnDiv.style.gap = '8px';
      uiDiv.appendChild(btnDiv);

      function createBtn(text, fn, primary) {
        var b = document.createElement('button');
        b.innerHTML = text;
        b.style.padding = '6px 14px';
        b.style.fontSize = '14px';
        b.style.cursor = 'pointer';
        b.style.background = primary ? '#dc3545' : '#f8f9fa';
        b.style.color = primary ? '#fff' : '#333';
        b.style.border = '1px solid #ccc';
        b.style.borderRadius = '4px';
        b.onclick = fn;
        return b;
      }

      // Drawing Logic
      function getIncY(x, frontX) {
        return amp * Math.sin(k * (x - frontX));
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Grid
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 1;
        for(var i=-2; i<=15; i++){
          var x = originX + i*grid;
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
          // Coordinates (excluding labels that might clutter)
          if(i===0 || i===9 || i===5) {
             ctx.fillStyle = '#aaa'; ctx.font = '10px sans-serif';
             ctx.fillText(i, x+2, originY+15);
          }
        }
        for(var j=-5; j<=5; j++){
          var y = originY + j*grid;
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(canvas.width, originY); ctx.stroke();
        
        // Wall (No "P" label)
        var wx = originX + wallX;
        ctx.beginPath(); ctx.moveTo(wx, 20); ctx.lineTo(wx, canvas.height-20); ctx.stroke();
        
        ctx.fillStyle = '#000'; ctx.font = 'bold 16px sans-serif';
        // "P" のラベルを削除し、"固定端"のみにする、またはシンプルに何も書かない
        // ここでは問題設定としての「固定端」であることを示すためにテキストだけ残すか、
        // ユーザー指示「P（固定端）を消して」を完全に守ってラベルごと消すか。
        // -> 指示通りラベルを消します。ただし物理的な壁(線)は残します。
        
        // ctx.fillText('固定端', wx - 35, 40); // 削除
        ctx.fillText('O', originX - 15, originY + 20);

        // --- Wave Calculation ---
        var tipRef = 2 * wallX - t; 

        // 1. Incident Wave
        if(showInc) {
          ctx.strokeStyle = '#007bff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          var first = true;
          for(var x = -3*grid; x <= t; x += 2) {
            if(x > wallX + 8*grid) break;
            var y = getIncY(x, t);
            var dx = originX + x;
            var dy = originY - y;
            if(x > wallX) ctx.globalAlpha = 0.3;
            else ctx.globalAlpha = 1.0;
            if(first){ ctx.moveTo(dx, dy); first=false; }
            else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }

        // 2. Reflected Wave
        if(showRef && t > wallX) {
          ctx.strokeStyle = '#28a745';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 4]); 
          ctx.beginPath();
          var first = true;
          for(var x = -3*grid; x <= wallX; x += 2) {
            if(x < tipRef) continue;
            var x_virt = 2*wallX - x;
            var y_virt = getIncY(x_virt, t);
            var y_ref = -y_virt;
            var dx = originX + x;
            var dy = originY - y_ref;
            if(first){ ctx.moveTo(dx, dy); first=false; }
            else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Source
          if(showInc) {
            ctx.strokeStyle = '#28a745';
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            var f2=true;
            for(var x=wallX; x<=t; x+=2) {
              if(x > wallX + 8*grid) break;
              var y = -getIncY(x, t);
              var dx = originX + x;
              var dy = originY - y;
              if(f2){ ctx.moveTo(dx, dy); f2=false; }
              else ctx.lineTo(dx, dy);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            // Center Dot for symmetry logic
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(wx, originY, 4, 0, Math.PI*2); ctx.fill();
          }
        }

        // 3. Composite Wave
        if(showComp && t > wallX) {
          ctx.strokeStyle = '#dc3545';
          ctx.lineWidth = 4;
          ctx.beginPath();
          var first = true;
          for(var x = -3*grid; x <= wallX; x += 2) {
             if(x > t) break;
             var y_sum = 0;
             y_sum += getIncY(x, t);
             if(x >= tipRef) {
                var x_virt = 2*wallX - x;
                y_sum += -getIncY(x_virt, t);
             }
             var dx = originX + x;
             var dy = originY - y_sum;
             if(first){ ctx.moveTo(dx, dy); first=false; }
             else ctx.lineTo(dx, dy);
          }
          ctx.stroke();
        }

        // 4. Highlight Answer Moment
        if(!isAnimating && Math.abs(t - targetFront) < 1.0) {
           ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
           ctx.fillRect(wx - 260, 10, 250, 35);
           ctx.strokeStyle = '#d00'; ctx.lineWidth=2; ctx.strokeRect(wx - 260, 10, 250, 35);

           ctx.fillStyle = '#d00';
           ctx.font = 'bold 16px sans-serif';
           ctx.fillText('★ 答えの瞬間 (定常波完成)', wx - 240, 34);
           
           // Nodes
           var nodes = [9, 5, 1, -3];
           ctx.lineWidth = 2; 
           ctx.strokeStyle = '#333';
           
           nodes.forEach(function(n){
             var nx = originX + n*grid;
             if(nx < 0) return;
             ctx.beginPath(); ctx.arc(nx, originY, 7, 0, Math.PI*2);
             ctx.fillStyle = '#fff'; ctx.fill(); ctx.stroke();
             
             // Label: "節"
             if(n===9 || n===5 || n===1) {
               ctx.fillStyle = '#333'; ctx.font = '12px sans-serif';
               ctx.fillText('節', nx-6, originY-14);
             }
           });
        }
      }

      function loop() {
        if(!isAnimating) return;
        t += waveSpeed;
        if(t >= targetFront) {
          t = targetFront;
          isAnimating = false;
        }
        draw();
        if(isAnimating) animId = requestAnimationFrame(loop);
      }

      // Buttons
      btnDiv.appendChild(createBtn('⏮ 最初から', function(){ 
        isAnimating=true; t=startFront; loop(); 
      }));
      btnDiv.appendChild(createBtn('⏪ -1コマ', function(){ 
        isAnimating=false; 
        t = Math.max(startFront, t - grid/4); 
        draw(); 
      }));
      btnDiv.appendChild(createBtn('再生 / 停止', function(){ 
        if(t >= targetFront) t = startFront; 
        isAnimating = !isAnimating; 
        if(isAnimating) loop(); 
      }));
      btnDiv.appendChild(createBtn('+1コマ ⏩', function(){ 
        isAnimating=false; 
        t += grid/4; 
        draw(); 
      }));
      btnDiv.appendChild(createBtn('★ 答えの瞬間', function(){ 
        isAnimating=false; 
        t = targetFront; 
        draw(); 
      }, true));

      // Init
      loop();
    })();
  </script>

  <div class="box-note">
    <strong>解答のポイント：</strong><br>
    <ul>
      <li><strong>合成波の形状</strong>：図の赤線のように、入射波・反射波それぞれの振幅を合わせた、大きな振幅（2倍）の波になります。</li>
      <li><strong>節（ふし）の位置</strong>：
        <ul>
          <li><strong>固定端（$x=9$）</strong>：壁は動かないので必ず節になります。</li>
          <li><strong>その他の節</strong>：壁から半波長（4目盛り）ごとに現れます。すなわち <strong>$x=5$、$x=1$</strong> の位置も節になります（図の白丸）。</li>
        </ul>
      </li>
    </ul>
  </div>
</div>

<div class="box-alert">
  <span class="box-alert-label">Point</span>
  <h3>定常波（定在波）の性質まとめ</h3>
  <p>
    左右から同じ波長の波が重なり合うと、その場で振動しているように見える「定常波」が生まれます。
  </p>
  <ul>
    <li><strong>節 (Node)</strong>：全く振動しない点。隣り合う節の間隔は $\frac{\lambda}{2}$。</li>
    <li><strong>腹 (Antinode)</strong>：最も大きく振動する点。振幅は元の波の2倍。節と節のちょうど中間に位置します。</li>
    <li><strong>固定端反射</strong>では、壁（端点）が必ず<strong>節</strong>になります。</li>
    <li><strong>自由端反射</strong>では、壁（端点）が必ず<strong>腹</strong>になります。</li>
  </ul>
</div>